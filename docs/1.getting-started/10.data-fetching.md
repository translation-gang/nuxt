---
title: 'Получение данных'
description: Nuxt предоставляет композаблы для получения данных в приложении.
navigation.icon: i-lucide-cable
---

В Nuxt есть два композабла и встроенная библиотека для запросов в браузере и на сервере: `useFetch`, [`useAsyncData`](/docs/4.x/api/composables/use-async-data) и `$fetch`.

Кратко:

- [`$fetch`](/docs/4.x/api/utils/dollarfetch) — самый простой способ выполнить сетевой запрос.
- [`useFetch`](/docs/4.x/api/composables/use-fetch) — обёртка над `$fetch`, запрос выполняется один раз при [универсальном рендеринге](/docs/4.x/guide/concepts/rendering#universal-rendering).
- [`useAsyncData`](/docs/4.x/api/composables/use-async-data) — похож на `useFetch`, но даёт более тонкий контроль.

У `useFetch` и `useAsyncData` общий набор опций и паттернов — они описаны в конце раздела.

## Зачем нужны `useFetch` и `useAsyncData`

Nuxt может выполнять изоморфный (универсальный) код и на сервере, и на клиенте. Если в setup-функции компонента Vue использовать только [`$fetch`](/docs/4.x/api/utils/dollarfetch), данные могут запрашиваться дважды: на сервере (при рендере HTML) и на клиенте (при гидрации). Это приводит к ошибкам гидрации, замедлению и нестабильному поведению.

Композаблы [`useFetch`](/docs/4.x/api/composables/use-fetch) и [`useAsyncData`](/docs/4.x/api/composables/use-async-data) решают это: данные, полученные на сервере, передаются на клиент в payload.

Payload — JavaScript-объект, доступный через [`useNuxtApp().payload`](/docs/4.x/api/composables/use-nuxt-app#payload). На клиенте он используется, чтобы не запрашивать те же данные повторно [при гидрации](/docs/4.x/guide/concepts/rendering#universal-rendering).

::tip
Смотрите эти данные в [Nuxt DevTools](https://devtools.nuxt.com) на вкладке **Payload**.
::

```vue [app/app.vue]
<script setup lang="ts">
const { data } = await useFetch('/api/data')

async function handleFormSubmit () {
  const res = await $fetch('/api/submit', {
    method: 'POST',
    body: {
      // My form data
    },
  })
}
</script>

<template>
  <div v-if="data == undefined">
    No data
  </div>
  <div v-else>
    <form @submit="handleFormSubmit">
      <!-- form input tags -->
    </form>
  </div>
</template>
```

В примере выше `useFetch` гарантирует, что запрос выполнится на сервере и результат попадёт в браузер. У `$fetch` такого механизма нет — его лучше использовать для запросов только с клиента.

### Suspense

Nuxt под капотом использует компонент Vue [`<Suspense>`](https://vuejs.org/guide/built-ins/suspense), чтобы не переходить на страницу до готовности асинхронных данных. Композаблы получения данных работают с этой возможностью и позволяют выбирать поведение для каждого вызова.

::note
Индикатор загрузки между переходами даёт [`<NuxtLoadingIndicator>`](/docs/4.x/api/components/nuxt-loading-indicator).
::

## `$fetch`

В Nuxt встроена библиотека [ofetch](https://github.com/unjs/ofetch), она автоимпортируется как `$fetch` по всему приложению.

```vue twoslash [pages/todos.vue]
<script setup lang="ts">
async function addTodo () {
  const todo = await $fetch('/api/todos', {
    method: 'POST',
    body: {
      // My todo data
    },
  })
}
</script>
```

::warning
Только `$fetch` не даёт [дедупликации запросов и блокировки навигации](/docs/4.x/getting-started/data-fetching#the-need-for-usefetch-and-useasyncdata). :br
Рекомендуется использовать `$fetch` для клиентских действий (по событиям) или вместе с [`useAsyncData`](/docs/4.x/getting-started/data-fetching#useasyncdata) при загрузке начальных данных компонента.
::

::read-more{to="/docs/4.x/api/utils/dollarfetch"}
Подробнее о `$fetch`.
::

### Передача заголовков клиента в API

При вызове `useFetch` на сервере Nuxt использует [`useRequestFetch`](/docs/4.x/api/composables/use-request-fetch) для проксирования заголовков и cookie клиента (кроме заголовков вроде `host`, которые не должны пересылаться).

```vue
<script setup lang="ts">
const { data } = await useFetch('/api/echo')
</script>
```

```ts
// /api/echo.ts
export default defineEventHandler(event => parseCookies(event))
```

Либо можно использовать [`useRequestHeaders`](/docs/4.x/api/composables/use-request-headers), чтобы получить cookie и отправить их в API при серверном запросе (инициированном с клиента). Изоморфный вызов `$fetch` с этими заголовками даёт API тот же заголовок `cookie`, что и браузер пользователя. Это нужно только если вы не используете `useFetch`.

```vue
<script setup lang="ts">
const headers = useRequestHeaders(['cookie'])

async function getCurrentUser () {
  return await $fetch('/api/me', { headers })
}
</script>
```

::tip
Заголовки можно проксировать автоматически через [`useRequestFetch`](/docs/4.x/api/composables/use-request-fetch).
::

::caution
Проксировать заголовки во внешний API нужно с осторожностью и только те, что действительно нужны. Не все заголовки безопасно пересылать. Не проксируйте:

- `host`, `accept`
- `content-length`, `content-md5`, `content-type`
- `x-forwarded-host`, `x-forwarded-port`, `x-forwarded-proto`
- `cf-connecting-ip`, `cf-ray`
::

## `useFetch`

Композабл [`useFetch`](/docs/4.x/api/composables/use-fetch) внутри использует `$fetch` для SSR-безопасных запросов в setup-функции.

```vue twoslash [app/app.vue]
<script setup lang="ts">
const { data: count } = await useFetch('/api/count')
</script>

<template>
  <p>Page visits: {{ count }}</p>
</template>
```

Это обёртка над композаблом [`useAsyncData`](/docs/4.x/api/composables/use-async-data) и утилитой `$fetch`.

:video-accordion{title="Видео Alexander Lichter: как не использовать useFetch неправильно" videoId="njsGVmcWviY"}

:read-more{to="/docs/4.x/api/composables/use-fetch"}

:link-example{to="/docs/4.x/examples/features/data-fetching"}

## `useAsyncData`

Композабл `useAsyncData` оборачивает асинхронную логику и возвращает результат после его разрешения.

::tip
`useFetch(url)` по сути эквивалентен `useAsyncData(url, () => event.$fetch(url))`. :br
Это удобная обёртка для типичного сценария. (Подробнее про `event.fetch` — в [`useRequestFetch`](/docs/4.x/api/composables/use-request-fetch).)
::

:video-accordion{title="Видео Alexander Lichter: разница между useFetch и useAsyncData" videoId="0X-aOpSGabA"}

[`useFetch`](/docs/4.x/api/composables/use-fetch) не всегда уместен — например, когда CMS или сторонний сервис даёт свой слой запросов. В таких случаях оборачивайте вызовы в [`useAsyncData`](/docs/4.x/api/composables/use-async-data), сохраняя преимущества композабла.

```vue [app/pages/users.vue]
<script setup lang="ts">
const { data, error } = await useAsyncData('users', () => myGetFunction('users'))

// This is also possible:
const { data, error } = await useAsyncData(() => myGetFunction('users'))
</script>
```

::note
The first argument of [`useAsyncData`](/docs/4.x/api/composables/use-async-data) is a unique key used to cache the response of the second argument, the querying function. This key can be ignored by directly passing the querying function, the key will be auto-generated.
:br :br
Since the autogenerated key only takes into account the file and line where `useAsyncData` is invoked, it is recommended to always create your own key to avoid unwanted behavior, like when you are creating your own custom composable wrapping `useAsyncData`.
:br :br
Setting a key can be useful to share the same data between components using [`useNuxtData`](/docs/4.x/api/composables/use-nuxt-data) or to [refresh specific data](/docs/4.x/api/utils/refresh-nuxt-data#refresh-specific-data).
::

```vue [app/pages/users/[id\\].vue]
<script setup lang="ts">
const { id } = useRoute().params

const { data, error } = await useAsyncData(`user:${id}`, () => {
  return myGetFunction('users', { id })
})
</script>
```

The `useAsyncData` composable is a great way to wrap and wait for multiple `$fetch` requests to be completed, and then process the results.

```vue
<script setup lang="ts">
const { data: discounts, status } = await useAsyncData('cart-discount', async (_nuxtApp, { signal }) => {
  const [coupons, offers] = await Promise.all([
    $fetch('/cart/coupons', { signal }),
    $fetch('/cart/offers', { signal }),
  ])

  return { coupons, offers }
})
// discounts.value.coupons
// discounts.value.offers
</script>
```

::note
`useAsyncData` is for fetching and caching data, not triggering side effects like calling Pinia actions, as this can cause unintended behavior such as repeated executions with nullish values. If you need to trigger side effects, use the [`callOnce`](/docs/4.x/api/utils/call-once) utility to do so.

```vue
<script setup lang="ts">
const offersStore = useOffersStore()

// you can't do this
await useAsyncData(() => offersStore.getOffer(route.params.slug))
</script>
```
::

::read-more{to="/docs/4.x/api/composables/use-async-data"}
Read more about `useAsyncData`.
::

## Возвращаемые значения

`useFetch` и `useAsyncData` возвращают один и тот же набор полей:

- `data`: результат переданной асинхронной функции.
- `refresh`/`execute`: функция для повторной загрузки данных из `handler`.
- `clear`: функция сбрасывает `data` в `undefined` (или в `options.default()`, если задано), обнуляет `error`, выставляет `status` в `idle` и отменяет текущие запросы.
- `error`: объект ошибки при неудачной загрузке.
- `status`: строка состояния запроса (`"idle"`, `"pending"`, `"success"`, `"error"`).

::note
`data`, `error` и `status` — Vue ref, в `<script setup>` доступны через `.value`.
::

По умолчанию Nuxt ждёт завершения `refresh`, прежде чем выполнить его снова.

::note
Если данные не запрашивались на сервере (например, при `server: false`), они _не будут_ загружены до завершения гидрации. Даже при await `useFetch` на клиенте `data` останется null внутри `<script setup>`.
::

## Опции

[`useAsyncData`](/docs/4.x/api/composables/use-async-data) и [`useFetch`](/docs/4.x/api/composables/use-fetch) возвращают один и тот же тип объекта и принимают общий набор опций последним аргументом. С их помощью можно управлять поведением: блокировкой навигации, кэшированием и моментом выполнения.

### Lazy (ленивая загрузка)

По умолчанию композаблы загрузки данных ждут разрешения асинхронной функции перед переходом на новую страницу (благодаря Vue Suspense). На клиенте это можно отключить опцией `lazy`. Тогда состояние загрузки нужно обрабатывать вручную через `status`.

```vue twoslash [app/app.vue]
<script setup lang="ts">
const { status, data: posts } = useFetch('/api/posts', {
  lazy: true,
})
</script>

<template>
  <!-- нужно обработать состояние загрузки -->
  <div v-if="status === 'pending'">
    Загрузка ...
  </div>
  <div v-else>
    <div v-for="post in posts">
      <!-- do something -->
    </div>
  </div>
</template>
```

Можно использовать [`useLazyFetch`](/docs/4.x/api/composables/use-lazy-fetch) и `useLazyAsyncData` для того же поведения.

```vue twoslash
<script setup lang="ts">
const { status, data: posts } = useLazyFetch('/api/posts')
</script>
```

::read-more{to="/docs/4.x/api/composables/use-lazy-fetch"}
Подробнее о `useLazyFetch`.
::

::read-more{to="/docs/4.x/api/composables/use-lazy-async-data"}
Подробнее о `useLazyAsyncData`.
::

:video-accordion{title="Видео Vue School: блокирующие и неблокирующие (lazy) запросы" videoId="1022000555" platform="vimeo"}

### Загрузка только на клиенте

По умолчанию композаблы выполняют асинхронную функцию и на клиенте, и на сервере. Опция `server: false` ограничивает выполнение только клиентом. При первой загрузке данные не будут запрошены до завершения гидрации — нужно обрабатывать состояние ожидания; при последующих переходах на клиенте данные будут загружаться до отображения страницы.

Вместе с опцией `lazy` это удобно для данных, не нужных при первом рендере (например, не влияющих на SEO).

```ts twoslash
/* This call is performed before hydration */
const articles = await useFetch('/api/article')

/* This call will only be performed on the client */
const { status, data: comments } = useFetch('/api/comments', {
  lazy: true,
  server: false,
})
```

Композабл `useFetch` нужно вызывать в setup или на верхнем уровне в хуках жизненного цикла; иначе используйте [метод `$fetch`](/docs/4.x/getting-started/data-fetching#fetch).

### Уменьшение размера полезной нагрузки

Опция `pick` уменьшает объём данных в HTML, возвращая только нужные поля.

```vue
<script setup lang="ts">
/* только поля, используемые в шаблоне */
const { data: mountain } = await useFetch('/api/mountains/everest', {
  pick: ['title', 'description'],
})
</script>

<template>
  <h1>{{ mountain.title }}</h1>
  <p>{{ mountain.description }}</p>
</template>
```

Для более гибкой обработки или преобразования нескольких объектов используйте функцию `transform`.

```ts
const { data: mountains } = await useFetch('/api/mountains', {
  transform: (mountains) => {
    return mountains.map(mountain => ({ title: mountain.title, description: mountain.description }))
  },
})
```

::note
Both `pick` and `transform` don't prevent the unwanted data from being fetched initially. But they will prevent unwanted data from being added to the payload transferred from server to client.
::

:video-accordion{title="Watch a video from Vue School on minimizing payload size" videoId="1026410430" platform="vimeo"}

### Caching and refetching

#### Keys

[`useFetch`](/docs/4.x/api/composables/use-fetch) and [`useAsyncData`](/docs/4.x/api/composables/use-async-data) use keys to prevent refetching the same data.

- [`useFetch`](/docs/4.x/api/composables/use-fetch) uses the provided URL as a key. Alternatively, a `key` value can be provided in the `options` object passed as a last argument.
- [`useAsyncData`](/docs/4.x/api/composables/use-async-data) uses its first argument as a key if it is a string. If the first argument is the handler function that performs the query, then a key that is unique to the file name and line number of the instance of `useAsyncData` will be generated for you.

::tip
To get the cached data by key, you can use [`useNuxtData`](/docs/4.x/api/composables/use-nuxt-data)
::

:video-accordion{title="Watch a video from Vue School on caching data with the key option" videoId="1026410044" platform="vimeo"}

#### Shared State and Option Consistency

When multiple components use the same key with `useAsyncData` or `useFetch`, they will share the same `data`, `error` and `status` refs. This ensures consistency across components but requires some options to be consistent.

The following options **must be consistent** across all calls with the same key:
- `handler` function
- `deep` option
- `transform` function
- `pick` array
- `getCachedData` function
- `default` value

```ts
// ❌ This will trigger a development warning
const { data: users1 } = useAsyncData('users', (_nuxtApp, { signal }) => $fetch('/api/users', { signal }), { deep: false })
const { data: users2 } = useAsyncData('users', (_nuxtApp, { signal }) => $fetch('/api/users', { signal }), { deep: true })
```

The following options **can safely differ** without triggering warnings:
- `server`
- `lazy`
- `immediate`
- `dedupe`
- `watch`

```ts
// ✅ This is allowed
const { data: users1 } = useAsyncData('users', (_nuxtApp, { signal }) => $fetch('/api/users', { signal }), { immediate: true })
const { data: users2 } = useAsyncData('users', (_nuxtApp, { signal }) => $fetch('/api/users', { signal }), { immediate: false })
```

If you need independent instances, use different keys:

```ts
// These are completely independent instances
const { data: users1 } = useAsyncData('users-1', (_nuxtApp, { signal }) => $fetch('/api/users', { signal }))
const { data: users2 } = useAsyncData('users-2', (_nuxtApp, { signal }) => $fetch('/api/users', { signal }))
```

#### Reactive Keys

You can use computed refs, plain refs or getter functions as keys, allowing for dynamic data fetching that automatically updates when dependencies change:

```ts
// Using a computed property as a key
const userId = ref('123')
const { data: user } = useAsyncData(
  computed(() => `user-${userId.value}`),
  () => fetchUser(userId.value),
)

// When userId changes, the data will be automatically refetched
// and the old data will be cleaned up if no other components use it
userId.value = '456'
```

#### Refresh and execute

If you want to fetch or refresh data manually, use the `execute` or `refresh` function provided by the composables.

```vue twoslash
<script setup lang="ts">
const { data, error, execute, refresh } = await useFetch('/api/users')
</script>

<template>
  <div>
    <p>{{ data }}</p>
    <button @click="() => refresh()">
      Refresh data
    </button>
  </div>
</template>
```

The `execute` function is an alias for `refresh` that works in exactly the same way but is more semantic for cases when the fetch is [not immediate](/docs/4.x/getting-started/data-fetching#not-immediate).

::tip
To globally refetch or invalidate cached data, see [`clearNuxtData`](/docs/4.x/api/utils/clear-nuxt-data) and [`refreshNuxtData`](/docs/4.x/api/utils/refresh-nuxt-data).
::

#### Clear

If you want to clear the data provided, for whatever reason, without needing to know the specific key to pass to `clearNuxtData`, you can use the `clear` function provided by the composables.

```vue twoslash
<script setup lang="ts">
const { data, clear } = await useFetch('/api/users')

const route = useRoute()
watch(() => route.path, (path) => {
  if (path === '/') {
    clear()
  }
})
</script>
```

#### Watch

To re-run your fetching function each time other reactive values in your application change, use the `watch` option. You can use it for one or multiple _watchable_ elements.

```vue twoslash
<script setup lang="ts">
const id = ref(1)

const { data, error, refresh } = await useFetch('/api/users', {
  /* Changing the id will trigger a refetch */
  watch: [id],
})
</script>
```

Note that **watching a reactive value won't change the URL fetched**. For example, this will keep fetching the same initial ID of the user because the URL is constructed at the moment the function is invoked.

```vue
<script setup lang="ts">
const id = ref(1)

const { data, error, refresh } = await useFetch(`/api/users/${id.value}`, {
  watch: [id],
})
</script>
```

If you need to change the URL based on a reactive value, you may want to use a [computed URL](/docs/4.x/getting-started/data-fetching#computed-url) instead.

When reactive fetch options are provided, they'll be automatically watched and trigger refetches. In some cases, it can be useful to opt-out of this behavior by specifying `watch: false`.

```ts
const id = ref(1)

// Won't automatically refetch when id changes
const { data, execute } = await useFetch('/api/users', {
  query: { id }, // id is watched by default
  watch: false, // disables automatic watching of id
})

// doesn't trigger refetch
id.value = 2
```

#### Computed URL

Sometimes you may need to compute a URL from reactive values, and refresh the data each time these change. Instead of juggling your way around, you can attach each param as a reactive value. Nuxt will automatically use the reactive value and re-fetch each time it changes.

```vue
<script setup lang="ts">
const id = ref(null)

const { data, status } = useLazyFetch('/api/user', {
  query: {
    user_id: id,
  },
})
</script>
```

In the case of more complex URL construction, you may use a callback as a [computed getter](https://vuejs.org/guide/essentials/computed) that returns the URL string.

Every time a dependency changes, the data will be fetched using the newly constructed URL. Combine this with [not-immediate](/docs/4.x/getting-started/data-fetching#not-immediate), and you can wait until the reactive element changes before fetching.

```vue
<script setup lang="ts">
const id = ref(null)

const { data, status } = useLazyFetch(() => `/api/users/${id.value}`, {
  immediate: false,
})

const pending = computed(() => status.value === 'pending')
</script>

<template>
  <div>
    <!-- disable the input while fetching -->
    <input
      v-model="id"
      type="number"
      :disabled="pending"
    >

    <div v-if="status === 'idle'">
      Type an user ID
    </div>

    <div v-else-if="pending">
      Loading ...
    </div>

    <div v-else>
      {{ data }}
    </div>
  </div>
</template>
```

If you need to force a refresh when other reactive values change, you can also [watch other values](/docs/4.x/getting-started/data-fetching#watch).

### Not immediate

The `useFetch` composable will start fetching data the moment is invoked. You may prevent this by setting `immediate: false`, for example, to wait for user interaction.

With that, you will need both the `status` to handle the fetch lifecycle, and `execute` to start the data fetch.

```vue
<script setup lang="ts">
const { data, error, execute, status } = await useLazyFetch('/api/comments', {
  immediate: false,
})
</script>

<template>
  <div v-if="status === 'idle'">
    <button @click="execute">
      Get data
    </button>
  </div>

  <div v-else-if="status === 'pending'">
    Loading comments...
  </div>

  <div v-else>
    {{ data }}
  </div>
</template>
```

For finer control, the `status` variable can be:

- `idle` when the fetch hasn't started
- `pending` when a fetch has started but not yet completed
- `error` when the fetch fails
- `success` when the fetch is completed successfully

## Передача заголовков и cookies

При вызове `$fetch` в браузере заголовки пользователя (например `cookie`) отправляются в API.

При SSR из соображений безопасности `$fetch` по умолчанию не передаёт cookies браузера и не пробрасывает cookies из ответа.

При вызове `useFetch` с относительным URL на сервере Nuxt использует [`useRequestFetch`](/docs/4.x/api/composables/use-request-fetch) для проксирования заголовков и cookies (кроме заголовков вроде `host`).

### Проброс cookies из серверного API в ответе SSR

Чтобы пробросить cookies из внутреннего запроса обратно клиенту, это нужно реализовать вручную.

```ts [app/composables/fetch.ts]
import { appendResponseHeader } from 'h3'
import type { H3Event } from 'h3'

export const fetchWithCookie = async (event: H3Event, url: string) => {
  /* Ответ от серверного эндпоинта */
  const res = await $fetch.raw(url)
  /* Cookies из ответа */
  const cookies = res.headers.getSetCookie()
  /* Добавляем каждый cookie к входящему ответу */
  for (const cookie of cookies) {
    appendResponseHeader(event, 'set-cookie', cookie)
  }
  return res._data
}
```

```vue
<script setup lang="ts">
// Этот композабл автоматически передаёт cookies клиенту
const event = useRequestEvent()

const { data: result } = await useAsyncData(() => fetchWithCookie(event!, '/api/with-cookie'))

onMounted(() => console.log(document.cookie))
</script>
```

## Поддержка Options API

В Options API можно использовать загрузку в стиле `asyncData`, обернув компонент в `defineNuxtComponent`.

```vue
<script>
export default defineNuxtComponent({
  /* Уникальный ключ через опцию fetchKey */
  fetchKey: 'hello',
  async asyncData () {
    return {
      hello: await $fetch('/api/hello'),
    }
  },
})
</script>
```

::note
Рекомендуемый способ объявления компонентов в Nuxt — `<script setup>` или `<script setup lang="ts">`.
::

:read-more{to="/docs/4.x/api/utils/define-nuxt-component"}

## Сериализация данных с сервера на клиент

При передаче данных с сервера на клиент через `useAsyncData` и `useLazyAsyncData` (и при использовании [payload Nuxt](/docs/4.x/api/composables/use-nuxt-app#payload)) payload сериализуется с помощью [`devalue`](https://github.com/sveltejs/devalue). Это позволяет передавать не только JSON, но и регулярные выражения, Date, Map, Set, `ref`, `reactive`, `shallowRef`, `shallowReactive`, `NuxtError` и др.

Для неподдерживаемых типов можно задать свой сериализатор/десериализатор. Подробнее в документации [`useNuxtApp`](/docs/4.x/api/composables/use-nuxt-app#payload).

::note
Это _не относится_ к данным из маршрутов в `server/`, запрошенным через `$fetch` или `useFetch` — см. следующий раздел.
::

## Сериализация данных из API-маршрутов

При запросе данных из директории `server` ответ сериализуется через `JSON.stringify`. Так как поддерживаются только примитивные типы JavaScript, Nuxt приводит тип возвращаемого значения `$fetch` и [`useFetch`](/docs/4.x/api/composables/use-fetch) к фактическому значению.

::read-more{icon="i-simple-icons-mdnwebdocs" to="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#description" target="_blank"}
Ограничения `JSON.stringify`.
::

### Пример

```ts [server/api/foo.ts]
export default defineEventHandler(() => {
  return new Date()
})
```

```vue [app/app.vue]
<script setup lang="ts">
// Type of `data` is inferred as string even though we returned a Date object
const { data } = await useFetch('/api/foo')
</script>
```

### Custom serializer function

To customize the serialization behavior, you can define a `toJSON` function on your returned object. If you define a `toJSON` method, Nuxt will respect the return type of the function and will not try to convert the types.

```ts [server/api/bar.ts]
export default defineEventHandler(() => {
  const data = {
    createdAt: new Date(),

    toJSON () {
      return {
        createdAt: {
          year: this.createdAt.getFullYear(),
          month: this.createdAt.getMonth(),
          day: this.createdAt.getDate(),
        },
      }
    },
  }
  return data
})
```

```vue [app/app.vue]
<script setup lang="ts">
// Type of `data` is inferred as
// {
//   createdAt: {
//     year: number
//     month: number
//     day: number
//   }
// }
const { data } = await useFetch('/api/bar')
</script>
```

### Using an alternative serializer

Nuxt does not currently support an alternative serializer to `JSON.stringify`. However, you can return your payload as a normal string and utilize the `toJSON` method to maintain type safety.

In the example below, we use [superjson](https://github.com/flightcontrolhq/superjson) as our serializer.

```ts [server/api/superjson.ts]
import superjson from 'superjson'

export default defineEventHandler(() => {
  const data = {
    createdAt: new Date(),

    // Workaround the type conversion
    toJSON () {
      return this
    },
  }

  // Serialize the output to string, using superjson
  return superjson.stringify(data) as unknown as typeof data
})
```

```vue [app/app.vue]
<script setup lang="ts">
import superjson from 'superjson'

// `date` is inferred as { createdAt: Date } and you can safely use the Date object methods
const { data } = await useFetch('/api/superjson', {
  transform: (value) => {
    return superjson.parse(value as unknown as string)
  },
})
</script>
```

## Рецепты

### Consuming SSE (Server-Sent Events) via POST request

::tip
If you're consuming SSE via GET request, you can use [`EventSource`](https://developer.mozilla.org/en-US/docs/Web/API/EventSource) or VueUse composable [`useEventSource`](https://vueuse.org/core/useeventsource/).
::

When consuming SSE via POST request, you need to handle the connection manually. Here's how you can do it:

```ts
// Make a POST request to the SSE endpoint
const response = await $fetch<ReadableStream>('/chats/ask-ai', {
  method: 'POST',
  body: {
    query: 'Hello AI, how are you?',
  },
  responseType: 'stream',
})

// Create a new ReadableStream from the response with TextDecoderStream to get the data as text
const reader = response.pipeThrough(new TextDecoderStream()).getReader()

// Read the chunk of data as we get it
while (true) {
  const { value, done } = await reader.read()

  if (done) { break }

  console.log('Received:', value)
}
```

### Making parallel requests

When requests don't rely on each other, you can make them in parallel with `Promise.all()` to boost performance.

```ts
const { data } = await useAsyncData((_nuxtApp, { signal }) => {
  return Promise.all([
    $fetch('/api/comments/', { signal }),
    $fetch('/api/author/12', { signal }),
  ])
})

const comments = computed(() => data.value?.[0])
const author = computed(() => data.value?.[1])
```

:video-accordion{title="Watch a video from Vue School on parallel data fetching" videoId="1024262536" platform="vimeo"}
