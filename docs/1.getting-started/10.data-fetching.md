---
title: 'Получение данных'
description: Nuxt предоставляет композаблы для получения данных в приложении.
navigation.icon: i-lucide-cable
---

В Nuxt есть два композабла и встроенная библиотека для запросов в браузере и на сервере: `useFetch`, [`useAsyncData`](/docs/4.x/api/composables/use-async-data) и `$fetch`.

Кратко:

- [`$fetch`](/docs/4.x/api/utils/dollarfetch) — самый простой способ выполнить сетевой запрос.
- [`useFetch`](/docs/4.x/api/composables/use-fetch) — обёртка над `$fetch`, запрос выполняется один раз при [универсальном рендеринге](/docs/4.x/guide/concepts/rendering#universal-rendering).
- [`useAsyncData`](/docs/4.x/api/composables/use-async-data) — похож на `useFetch`, но даёт более тонкий контроль.

У `useFetch` и `useAsyncData` общий набор опций и паттернов — они описаны в конце раздела.

## Зачем нужны `useFetch` и `useAsyncData`

Nuxt может выполнять изоморфный (универсальный) код и на сервере, и на клиенте. Если в setup-функции компонента Vue использовать только [`$fetch`](/docs/4.x/api/utils/dollarfetch), данные могут запрашиваться дважды: на сервере (при рендере HTML) и на клиенте (при гидрации). Это приводит к ошибкам гидрации, замедлению и нестабильному поведению.

Композаблы [`useFetch`](/docs/4.x/api/composables/use-fetch) и [`useAsyncData`](/docs/4.x/api/composables/use-async-data) решают это: данные, полученные на сервере, передаются на клиент в payload.

Payload — JavaScript-объект, доступный через [`useNuxtApp().payload`](/docs/4.x/api/composables/use-nuxt-app#payload). На клиенте он используется, чтобы не запрашивать те же данные повторно [при гидрации](/docs/4.x/guide/concepts/rendering#universal-rendering).

::tip
Смотрите эти данные в [Nuxt DevTools](https://devtools.nuxt.com) на вкладке **Payload**.
::

```vue [app/app.vue]
<script setup lang="ts">
const { data } = await useFetch('/api/data')

async function handleFormSubmit () {
  const res = await $fetch('/api/submit', {
    method: 'POST',
    body: {
      // My form data
    },
  })
}
</script>

<template>
  <div v-if="data == undefined">
    No data
  </div>
  <div v-else>
    <form @submit="handleFormSubmit">
      <!-- form input tags -->
    </form>
  </div>
</template>
```

В примере выше `useFetch` гарантирует, что запрос выполнится на сервере и результат попадёт в браузер. У `$fetch` такого механизма нет — его лучше использовать для запросов только с клиента.

### Suspense

Nuxt под капотом использует компонент Vue [`<Suspense>`](https://vuejs.org/guide/built-ins/suspense), чтобы не переходить на страницу до готовности асинхронных данных. Композаблы получения данных работают с этой возможностью и позволяют выбирать поведение для каждого вызова.

::note
Индикатор загрузки между переходами даёт [`<NuxtLoadingIndicator>`](/docs/4.x/api/components/nuxt-loading-indicator).
::

## `$fetch`

В Nuxt встроена библиотека [ofetch](https://github.com/unjs/ofetch), она автоимпортируется как `$fetch` по всему приложению.

```vue twoslash [pages/todos.vue]
<script setup lang="ts">
async function addTodo () {
  const todo = await $fetch('/api/todos', {
    method: 'POST',
    body: {
      // My todo data
    },
  })
}
</script>
```

::warning
Только `$fetch` не даёт [дедупликации запросов и блокировки навигации](/docs/4.x/getting-started/data-fetching#the-need-for-usefetch-and-useasyncdata). :br
Рекомендуется использовать `$fetch` для клиентских действий (по событиям) или вместе с [`useAsyncData`](/docs/4.x/getting-started/data-fetching#useasyncdata) при загрузке начальных данных компонента.
::

::read-more{to="/docs/4.x/api/utils/dollarfetch"}
Подробнее о `$fetch`.
::

### Передача заголовков клиента в API

При вызове `useFetch` на сервере Nuxt использует [`useRequestFetch`](/docs/4.x/api/composables/use-request-fetch) для проксирования заголовков и cookie клиента (кроме заголовков вроде `host`, которые не должны пересылаться).

```vue
<script setup lang="ts">
const { data } = await useFetch('/api/echo')
</script>
```

```ts
// /api/echo.ts
export default defineEventHandler(event => parseCookies(event))
```

Либо можно использовать [`useRequestHeaders`](/docs/4.x/api/composables/use-request-headers), чтобы получить cookie и отправить их в API при серверном запросе (инициированном с клиента). Изоморфный вызов `$fetch` с этими заголовками даёт API тот же заголовок `cookie`, что и браузер пользователя. Это нужно только если вы не используете `useFetch`.

```vue
<script setup lang="ts">
const headers = useRequestHeaders(['cookie'])

async function getCurrentUser () {
  return await $fetch('/api/me', { headers })
}
</script>
```

::tip
Заголовки можно проксировать автоматически через [`useRequestFetch`](/docs/4.x/api/composables/use-request-fetch).
::

::caution
Проксировать заголовки во внешний API нужно с осторожностью и только те, что действительно нужны. Не все заголовки безопасно пересылать. Не проксируйте:

- `host`, `accept`
- `content-length`, `content-md5`, `content-type`
- `x-forwarded-host`, `x-forwarded-port`, `x-forwarded-proto`
- `cf-connecting-ip`, `cf-ray`
::

## `useFetch`

Композабл [`useFetch`](/docs/4.x/api/composables/use-fetch) внутри использует `$fetch` для SSR-безопасных запросов в setup-функции.

```vue twoslash [app/app.vue]
<script setup lang="ts">
const { data: count } = await useFetch('/api/count')
</script>

<template>
  <p>Page visits: {{ count }}</p>
</template>
```

Это обёртка над композаблом [`useAsyncData`](/docs/4.x/api/composables/use-async-data) и утилитой `$fetch`.

:video-accordion{title="Видео Alexander Lichter: как не использовать useFetch неправильно" videoId="njsGVmcWviY"}

:read-more{to="/docs/4.x/api/composables/use-fetch"}

:link-example{to="/docs/4.x/examples/features/data-fetching"}

## `useAsyncData`

Композабл `useAsyncData` оборачивает асинхронную логику и возвращает результат после его разрешения.

::tip
`useFetch(url)` по сути эквивалентен `useAsyncData(url, () => event.$fetch(url))`. :br
Это удобная обёртка для типичного сценария. (Подробнее про `event.fetch` — в [`useRequestFetch`](/docs/4.x/api/composables/use-request-fetch).)
::

:video-accordion{title="Видео Alexander Lichter: разница между useFetch и useAsyncData" videoId="0X-aOpSGabA"}

[`useFetch`](/docs/4.x/api/composables/use-fetch) не всегда уместен — например, когда CMS или сторонний сервис даёт свой слой запросов. В таких случаях оборачивайте вызовы в [`useAsyncData`](/docs/4.x/api/composables/use-async-data), сохраняя преимущества композабла.

```vue [app/pages/users.vue]
<script setup lang="ts">
const { data, error } = await useAsyncData('users', () => myGetFunction('users'))

// This is also possible:
const { data, error } = await useAsyncData(() => myGetFunction('users'))
</script>
```

::note
Первый аргумент [`useAsyncData`](/docs/4.x/api/composables/use-async-data) — уникальный ключ для кэширования ответа функции запроса (второй аргумент). Можно передать только функцию, тогда ключ сгенерируется автоматически.
:br :br
Автогенерируемый ключ зависит только от файла и строки вызова. Рекомендуется задавать свой ключ, особенно при обёртке `useAsyncData` в собственном композабле.
:br :br
Ключ нужен для общего доступа к данным через [`useNuxtData`](/docs/4.x/api/composables/use-nuxt-data) или [обновления конкретных данных](/docs/4.x/api/utils/refresh-nuxt-data#refresh-specific-data).
::

```vue [app/pages/users/[id\\].vue]
<script setup lang="ts">
const { id } = useRoute().params

const { data, error } = await useAsyncData(`user:${id}`, () => {
  return myGetFunction('users', { id })
})
</script>
```

Композабл `useAsyncData` удобен, когда нужно выполнить несколько запросов `$fetch` и обработать результат.

```vue
<script setup lang="ts">
const { data: discounts, status } = await useAsyncData('cart-discount', async (_nuxtApp, { signal }) => {
  const [coupons, offers] = await Promise.all([
    $fetch('/cart/coupons', { signal }),
    $fetch('/cart/offers', { signal }),
  ])

  return { coupons, offers }
})
// discounts.value.coupons
// discounts.value.offers
</script>
```

::note
`useAsyncData` предназначен для загрузки и кэширования данных, а не для побочных эффектов (например, вызова экшенов Pinia) — это может привести к повторным вызовам с null. Для побочных эффектов используйте утилиту [`callOnce`](/docs/4.x/api/utils/call-once).

```vue
<script setup lang="ts">
const offersStore = useOffersStore()

// так делать не стоит
await useAsyncData(() => offersStore.getOffer(route.params.slug))
</script>
```
::

::read-more{to="/docs/4.x/api/composables/use-async-data"}
Подробнее о `useAsyncData`.
::

## Возвращаемые значения

`useFetch` и `useAsyncData` возвращают один и тот же набор полей:

- `data`: результат переданной асинхронной функции.
- `refresh`/`execute`: функция для повторной загрузки данных из `handler`.
- `clear`: функция сбрасывает `data` в `undefined` (или в `options.default()`, если задано), обнуляет `error`, выставляет `status` в `idle` и отменяет текущие запросы.
- `error`: объект ошибки при неудачной загрузке.
- `status`: строка состояния запроса (`"idle"`, `"pending"`, `"success"`, `"error"`).

::note
`data`, `error` и `status` — Vue ref, в `<script setup>` доступны через `.value`.
::

По умолчанию Nuxt ждёт завершения `refresh`, прежде чем выполнить его снова.

::note
Если данные не запрашивались на сервере (например, при `server: false`), они _не будут_ загружены до завершения гидрации. Даже при await `useFetch` на клиенте `data` останется null внутри `<script setup>`.
::

## Опции

[`useAsyncData`](/docs/4.x/api/composables/use-async-data) и [`useFetch`](/docs/4.x/api/composables/use-fetch) возвращают один и тот же тип объекта и принимают общий набор опций последним аргументом. С их помощью можно управлять поведением: блокировкой навигации, кэшированием и моментом выполнения.

### Lazy (ленивая загрузка)

По умолчанию композаблы загрузки данных ждут разрешения асинхронной функции перед переходом на новую страницу (благодаря Vue Suspense). На клиенте это можно отключить опцией `lazy`. Тогда состояние загрузки нужно обрабатывать вручную через `status`.

```vue twoslash [app/app.vue]
<script setup lang="ts">
const { status, data: posts } = useFetch('/api/posts', {
  lazy: true,
})
</script>

<template>
  <!-- нужно обработать состояние загрузки -->
  <div v-if="status === 'pending'">
    Загрузка ...
  </div>
  <div v-else>
    <div v-for="post in posts">
      <!-- do something -->
    </div>
  </div>
</template>
```

Можно использовать [`useLazyFetch`](/docs/4.x/api/composables/use-lazy-fetch) и `useLazyAsyncData` для того же поведения.

```vue twoslash
<script setup lang="ts">
const { status, data: posts } = useLazyFetch('/api/posts')
</script>
```

::read-more{to="/docs/4.x/api/composables/use-lazy-fetch"}
Подробнее о `useLazyFetch`.
::

::read-more{to="/docs/4.x/api/composables/use-lazy-async-data"}
Подробнее о `useLazyAsyncData`.
::

:video-accordion{title="Видео Vue School: блокирующие и неблокирующие (lazy) запросы" videoId="1022000555" platform="vimeo"}

### Загрузка только на клиенте

По умолчанию композаблы выполняют асинхронную функцию и на клиенте, и на сервере. Опция `server: false` ограничивает выполнение только клиентом. При первой загрузке данные не будут запрошены до завершения гидрации — нужно обрабатывать состояние ожидания; при последующих переходах на клиенте данные будут загружаться до отображения страницы.

Вместе с опцией `lazy` это удобно для данных, не нужных при первом рендере (например, не влияющих на SEO).

```ts twoslash
/* Вызов выполняется до гидрации */
const articles = await useFetch('/api/article')

/* Этот запрос выполнится только на клиенте */
const { status, data: comments } = useFetch('/api/comments', {
  lazy: true,
  server: false,
})
```

Композабл `useFetch` нужно вызывать в setup или на верхнем уровне в хуках жизненного цикла; иначе используйте [метод `$fetch`](/docs/4.x/getting-started/data-fetching#fetch).

### Уменьшение размера полезной нагрузки

Опция `pick` уменьшает объём данных в HTML, возвращая только нужные поля.

```vue
<script setup lang="ts">
/* только поля, используемые в шаблоне */
const { data: mountain } = await useFetch('/api/mountains/everest', {
  pick: ['title', 'description'],
})
</script>

<template>
  <h1>{{ mountain.title }}</h1>
  <p>{{ mountain.description }}</p>
</template>
```

Для более гибкой обработки или преобразования нескольких объектов используйте функцию `transform`.

```ts
const { data: mountains } = await useFetch('/api/mountains', {
  transform: (mountains) => {
    return mountains.map(mountain => ({ title: mountain.title, description: mountain.description }))
  },
})
```

::note
`pick` и `transform` не отменяют первоначальную загрузку данных, но не добавляют лишние данные в payload при передаче с сервера на клиент.
::

:video-accordion{title="Видео Vue School: минимизация размера payload" videoId="1026410430" platform="vimeo"}

### Кэширование и повторная загрузка

#### Ключи

[`useFetch`](/docs/4.x/api/composables/use-fetch) и [`useAsyncData`](/docs/4.x/api/composables/use-async-data) используют ключи, чтобы не запрашивать одни и те же данные повторно.

- [`useFetch`](/docs/4.x/api/composables/use-fetch) использует URL как ключ. Либо можно передать `key` в объекте опций последним аргументом.
- [`useAsyncData`](/docs/4.x/api/composables/use-async-data) использует первый аргумент как ключ, если это строка. Если передан handler, ключ генерируется по имени файла и номеру строки.

::tip
Получить закэшированные данные по ключу: [`useNuxtData`](/docs/4.x/api/composables/use-nuxt-data).
::

:video-accordion{title="Видео Vue School: кэширование с опцией key" videoId="1026410044" platform="vimeo"}

#### Общее состояние и согласованность опций

При одном и том же ключе у нескольких компонентов общими будут refs `data`, `error` и `status`. Чтобы всё работало предсказуемо, часть опций должна совпадать.

**Должны совпадать** при одном ключе:
- функция `handler`
- опция `deep`
- функция `transform`
- массив `pick`
- функция `getCachedData`
- значение `default`

```ts
// ❌ Вызовет предупреждение в режиме разработки
const { data: users1 } = useAsyncData('users', (_nuxtApp, { signal }) => $fetch('/api/users', { signal }), { deep: false })
const { data: users2 } = useAsyncData('users', (_nuxtApp, { signal }) => $fetch('/api/users', { signal }), { deep: true })
```

**Могут различаться** без предупреждений:
- `server`
- `lazy`
- `immediate`
- `dedupe`
- `watch`

```ts
// ✅ Допустимо
const { data: users1 } = useAsyncData('users', (_nuxtApp, { signal }) => $fetch('/api/users', { signal }), { immediate: true })
const { data: users2 } = useAsyncData('users', (_nuxtApp, { signal }) => $fetch('/api/users', { signal }), { immediate: false })
```

Для независимых экземпляров используйте разные ключи:

```ts
// Полностью независимые экземпляры
const { data: users1 } = useAsyncData('users-1', (_nuxtApp, { signal }) => $fetch('/api/users', { signal }))
const { data: users2 } = useAsyncData('users-2', (_nuxtApp, { signal }) => $fetch('/api/users', { signal }))
```

#### Реактивные ключи

В качестве ключа можно передать computed ref, обычный ref или getter — тогда загрузка будет обновляться при изменении зависимостей:

```ts
// Ключ как computed
const userId = ref('123')
const { data: user } = useAsyncData(
  computed(() => `user-${userId.value}`),
  () => fetchUser(userId.value),
)

// При смене userId данные перезапросятся,
// старые удалятся, если больше нигде не используются
userId.value = '456'
```

#### Refresh и execute

Чтобы запросить или обновить данные вручную, используйте `execute` или `refresh`, возвращаемые композаблами.

```vue twoslash
<script setup lang="ts">
const { data, error, execute, refresh } = await useFetch('/api/users')
</script>

<template>
  <div>
    <p>{{ data }}</p>
    <button @click="() => refresh()">
      Обновить данные
    </button>
  </div>
</template>
```

`execute` — алиас для `refresh`, удобен, когда загрузка [не выполняется сразу](/docs/4.x/getting-started/data-fetching#not-immediate).

::tip
Глобально обновить или сбросить кэш: [`clearNuxtData`](/docs/4.x/api/utils/clear-nuxt-data) и [`refreshNuxtData`](/docs/4.x/api/utils/refresh-nuxt-data).
::

#### Clear (очистка)

Чтобы очистить данные без вызова `clearNuxtData` с конкретным ключом, используйте функцию `clear` от композабла.

```vue twoslash
<script setup lang="ts">
const { data, clear } = await useFetch('/api/users')

const route = useRoute()
watch(() => route.path, (path) => {
  if (path === '/') {
    clear()
  }
})
</script>
```

#### Watch (наблюдение)

Чтобы перезапускать загрузку при изменении реактивных значений, используйте опцию `watch` с одним или несколькими источниками.

```vue twoslash
<script setup lang="ts">
const id = ref(1)

const { data, error, refresh } = await useFetch('/api/users', {
  /* Изменение id вызовет повторный запрос */
  watch: [id],
})
</script>
```

**Наблюдение за значением не меняет URL запроса.** В примере ниже будет всегда запрашиваться один и тот же начальный id, так как URL формируется в момент вызова:

```vue
<script setup lang="ts">
const id = ref(1)

const { data, error, refresh } = await useFetch(`/api/users/${id.value}`, {
  watch: [id],
})
</script>
```

Чтобы URL зависел от реактивного значения, используйте [computed URL](/docs/4.x/getting-started/data-fetching#computed-url).

При реактивных опциях запроса они по умолчанию отслеживаются и вызывают повторную загрузку. Отключить это можно через `watch: false`.

```ts
const id = ref(1)

// Не будет автоматически перезапрашивать при смене id
const { data, execute } = await useFetch('/api/users', {
  query: { id }, // id по умолчанию отслеживается
  watch: false,
})

// повторный запрос не выполнится
id.value = 2
```

#### Вычисляемый URL

Если URL нужно собирать из реактивных значений и обновлять данные при их смене, можно передать параметры как реактивные значения — Nuxt будет подставлять их и перезапрашивать при изменениях.

```vue
<script setup lang="ts">
const id = ref(null)

const { data, status } = useLazyFetch('/api/user', {
  query: {
    user_id: id,
  },
})
</script>
```

Для сложного URL можно передать [computed getter](https://vuejs.org/guide/essentials/computed), возвращающий строку URL.

При изменении зависимости данные запрашиваются по новому URL. В сочетании с [not-immediate](/docs/4.x/getting-started/data-fetching#not-immediate) загрузка начнётся только после изменения значения.

```vue
<script setup lang="ts">
const id = ref(null)

const { data, status } = useLazyFetch(() => `/api/users/${id.value}`, {
  immediate: false,
})

const pending = computed(() => status.value === 'pending')
</script>

<template>
  <div>
    <!-- поле отключено во время загрузки -->
    <input
      v-model="id"
      type="number"
      :disabled="pending"
    >

    <div v-if="status === 'idle'">
      Введите ID пользователя
    </div>

    <div v-else-if="pending">
      Загрузка ...
    </div>

    <div v-else>
      {{ data }}
    </div>
  </div>
</template>
```

Принудительное обновление при смене других значений: [watch](/docs/4.x/getting-started/data-fetching#watch).

### Не сразу (not immediate)

По умолчанию `useFetch` начинает загрузку при вызове. Чтобы отложить до действия пользователя, задайте `immediate: false`.

В этом случае понадобятся `status` для отображения состояния и `execute` для запуска загрузки.

```vue
<script setup lang="ts">
const { data, error, execute, status } = await useLazyFetch('/api/comments', {
  immediate: false,
})
</script>

<template>
  <div v-if="status === 'idle'">
    <button @click="execute">
      Загрузить данные
    </button>
  </div>

  <div v-else-if="status === 'pending'">
    Загрузка комментариев...
  </div>

  <div v-else>
    {{ data }}
  </div>
</template>
```

Значения `status`:

- `idle` — запрос ещё не запущен
- `pending` — запрос выполняется
- `error` — ошибка
- `success` — загрузка завершена успешно

## Передача заголовков и cookies

При вызове `$fetch` в браузере заголовки пользователя (например `cookie`) отправляются в API.

При SSR из соображений безопасности `$fetch` по умолчанию не передаёт cookies браузера и не пробрасывает cookies из ответа.

При вызове `useFetch` с относительным URL на сервере Nuxt использует [`useRequestFetch`](/docs/4.x/api/composables/use-request-fetch) для проксирования заголовков и cookies (кроме заголовков вроде `host`).

### Проброс cookies из серверного API в ответе SSR

Чтобы пробросить cookies из внутреннего запроса обратно клиенту, это нужно реализовать вручную.

```ts [app/composables/fetch.ts]
import { appendResponseHeader } from 'h3'
import type { H3Event } from 'h3'

export const fetchWithCookie = async (event: H3Event, url: string) => {
  /* Ответ от серверного эндпоинта */
  const res = await $fetch.raw(url)
  /* Cookies из ответа */
  const cookies = res.headers.getSetCookie()
  /* Добавляем каждый cookie к входящему ответу */
  for (const cookie of cookies) {
    appendResponseHeader(event, 'set-cookie', cookie)
  }
  return res._data
}
```

```vue
<script setup lang="ts">
// Этот композабл автоматически передаёт cookies клиенту
const event = useRequestEvent()

const { data: result } = await useAsyncData(() => fetchWithCookie(event!, '/api/with-cookie'))

onMounted(() => console.log(document.cookie))
</script>
```

## Поддержка Options API

В Options API можно использовать загрузку в стиле `asyncData`, обернув компонент в `defineNuxtComponent`.

```vue
<script>
export default defineNuxtComponent({
  /* Уникальный ключ через опцию fetchKey */
  fetchKey: 'hello',
  async asyncData () {
    return {
      hello: await $fetch('/api/hello'),
    }
  },
})
</script>
```

::note
Рекомендуемый способ объявления компонентов в Nuxt — `<script setup>` или `<script setup lang="ts">`.
::

:read-more{to="/docs/4.x/api/utils/define-nuxt-component"}

## Сериализация данных с сервера на клиент

При передаче данных с сервера на клиент через `useAsyncData` и `useLazyAsyncData` (и при использовании [payload Nuxt](/docs/4.x/api/composables/use-nuxt-app#payload)) payload сериализуется с помощью [`devalue`](https://github.com/sveltejs/devalue). Это позволяет передавать не только JSON, но и регулярные выражения, Date, Map, Set, `ref`, `reactive`, `shallowRef`, `shallowReactive`, `NuxtError` и др.

Для неподдерживаемых типов можно задать свой сериализатор/десериализатор. Подробнее в документации [`useNuxtApp`](/docs/4.x/api/composables/use-nuxt-app#payload).

::note
Это _не относится_ к данным из маршрутов в `server/`, запрошенным через `$fetch` или `useFetch` — см. следующий раздел.
::

## Сериализация данных из API-маршрутов

При запросе данных из директории `server` ответ сериализуется через `JSON.stringify`. Так как поддерживаются только примитивные типы JavaScript, Nuxt приводит тип возвращаемого значения `$fetch` и [`useFetch`](/docs/4.x/api/composables/use-fetch) к фактическому значению.

::read-more{icon="i-simple-icons-mdnwebdocs" to="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#description" target="_blank"}
Ограничения `JSON.stringify`.
::

### Пример

```ts [server/api/foo.ts]
export default defineEventHandler(() => {
  return new Date()
})
```

```vue [app/app.vue]
<script setup lang="ts">
// Тип `data` выводится как string, хотя мы вернули Date
const { data } = await useFetch('/api/foo')
</script>
```

### Собственная функция сериализации

Чтобы изменить сериализацию, определите у возвращаемого объекта метод `toJSON`. Nuxt будет использовать тип возвращаемого значения и не станет приводить типы.

```ts [server/api/bar.ts]
export default defineEventHandler(() => {
  const data = {
    createdAt: new Date(),

    toJSON () {
      return {
        createdAt: {
          year: this.createdAt.getFullYear(),
          month: this.createdAt.getMonth(),
          day: this.createdAt.getDate(),
        },
      }
    },
  }
  return data
})
```

```vue [app/app.vue]
<script setup lang="ts">
// Тип `data` выводится как { createdAt: { year, month, day } }
const { data } = await useFetch('/api/bar')
</script>
```

### Альтернативный сериализатор

Nuxt не поддерживает замену `JSON.stringify`. Можно вернуть payload строкой и использовать метод `toJSON` для сохранения типов.

В примере ниже используется [superjson](https://github.com/flightcontrolhq/superjson).

```ts [server/api/superjson.ts]
import superjson from 'superjson'

export default defineEventHandler(() => {
  const data = {
    createdAt: new Date(),

    // Обход приведения типов
    toJSON () {
      return this
    },
  }

  // Сериализация в строку через superjson
  return superjson.stringify(data) as unknown as typeof data
})
```

```vue [app/app.vue]
<script setup lang="ts">
import superjson from 'superjson'

// `data` выводится как { createdAt: Date }, можно использовать методы Date
const { data } = await useFetch('/api/superjson', {
  transform: (value) => {
    return superjson.parse(value as unknown as string)
  },
})
</script>
```

## Рецепты

### SSE (Server-Sent Events) через POST

::tip
Для SSE через GET можно использовать [`EventSource`](https://developer.mozilla.org/en-US/docs/Web/API/EventSource) или композабл VueUse [`useEventSource`](https://vueuse.org/core/useeventsource/).
::

При POST-запросе к SSE-эндпоинту соединение нужно обрабатывать вручную:

```ts
// POST-запрос к SSE-эндпоинту
const response = await $fetch<ReadableStream>('/chats/ask-ai', {
  method: 'POST',
  body: {
    query: 'Hello AI, how are you?',
  },
  responseType: 'stream',
})

// ReadableStream с TextDecoderStream для чтения текста
const reader = response.pipeThrough(new TextDecoderStream()).getReader()

while (true) {
  const { value, done } = await reader.read()

  if (done) { break }

  console.log('Received:', value)
}
```

### Параллельные запросы

Если запросы не зависят друг от друга, их можно выполнять параллельно через `Promise.all()`:

```ts
const { data } = await useAsyncData((_nuxtApp, { signal }) => {
  return Promise.all([
    $fetch('/api/comments/', { signal }),
    $fetch('/api/author/12', { signal }),
  ])
})

const comments = computed(() => data.value?.[0])
const author = computed(() => data.value?.[1])
```

:video-accordion{title="Видео Vue School: параллельная загрузка данных" videoId="1024262536" platform="vimeo"}
