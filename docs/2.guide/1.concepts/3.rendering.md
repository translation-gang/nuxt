---
title: 'Режимы рендеринга'
description: 'Узнайте о разных режимах рендеринга, доступных в Nuxt.'
---

Nuxt поддерживает разные режимы рендеринга: [универсальный рендеринг](#universal-rendering), [рендеринг на клиенте](#client-side-rendering), а также предоставляет [гибридный рендеринг](#hybrid-rendering) и возможность рендерить ваше приложение на [пограничных CDN-серверах](#edge-side-rendering).

И браузер, и сервер могут интерпретировать код JavaScript для преобразования компонентов Vue.js в HTML-элементы. Этот шаг называется **рендеринг**. Nuxt поддерживает как **универсальный**, так и **клиентский** рендеринги. У этих двух подходов есть преимущества и недостатки, которые мы рассмотрим.

По умолчанию Nuxt использует **универсальный рендеринг**, чтобы обеспечить лучший пользовательский опыт, производительность и оптимизировать индексацию поисковыми системами, но вы можете переключать режимы рендеринга с помощью [одной строки конфигурации](/docs/api/nuxt-config#ssr).

## Универсальный Рендеринг

Этот шаг аналогичен традиционному **рендерингу на сервере**, выполняемому приложениями PHP или Ruby. Когда браузер запрашивает URL-адрес с включенным универсальным рендерингом, Nuxt выполняет код JavaScript (Vue.js) в серверной среде и возвращает браузеру полностью отрендеренную HTML-страницу. Nuxt также может вернуть полностью отрендеренную HTML-страницу из кэша, если она была сгенерирована заранее. Пользователи сразу получают контент нашего приложения, в отличие от рендеринга на клиенте.

После загрузки HTML-документа браузер интерпретирует его, и Vue.js берет управление документом на себя. Тот же самый JavaScript-код, который когда-то выполнялся на сервере, запускается на клиенте (браузере) **снова** в фоновом режиме, теперь обеспечивая интерактивность (отсюда **Универсальный рендеринг**) путем привязки своих слушателей к HTML. Это называется **Гидратация**. Когда гидратация завершена, страница может пользоваться такими преимуществами, как динамические интерфейсы и переходы между страницами.

Универсальный рендеринг позволяет Nuxt-приложению обеспечить быструю загрузку страницы, сохраняя при этом преимущества рендеринга на клиенте. Более того, поскольку контент уже присутствует в HTML-документе, поисковые роботы могут индексировать его без дополнительных затрат.

![Пользователи могут получить доступ к статическому содержимому, когда HTML-документ загружен. Затем гидратация обеспечивает интерактивность страницы.](/assets/docs/concepts/rendering/ssr.svg)

**Что такое серверный рендеринг и что такое клиентский рендеринг?**

Обычно спрашивают, какие части файла Vue работают на сервере и/или клиенте в универсальном режиме рендеринга.

```vue [app.vue]
<script setup lang="ts">
const counter = ref(0); // выполняется в серверной и клиентской средах

const handleClick = () => {
  counter.value++; // выполняется только в клиентской среде
};
</script>

<template>
  <div>
    <p>Count: {{ counter }}</p>
    <button @click="handleClick">Increment</button>
  </div>
</template>
```

При первом запросе `counter` ref инициализируется на сервере, поскольку она отображается внутри тега `<p>`. Содержимое `handleClick` здесь никогда не выполняется. Во время гидратации в браузере `counter` ref инициализируется заново. Наконец, `handleClick` привязывает себя к кнопке; поэтому разумно делать вывод, что тело `handleClick` всегда будет выполняться в среде браузера.

[Middlewares](/docs/guide/directory-structure/middleware) и [страницы](/docs/guide/directory-structure/pages) запускаются на сервере и на клиенте во время гидрации. [Плагины](/docs/guide/directory-structure/plugins) могут быть отрендерены как на сервере, так и на клиенте. [Компоненты](/docs/guide/directory-structure/components) можно заставить работать только на клиенте. [Композаблы](/docs/guide/directory-structure/composables) и [утилиты](/docs/guide/directory-structure/utils) рендерятся в зависимости от контекста их использования.

**Преимущества рендеринга на сервера:**
- **Производительность**: Пользователи получают немедленный доступ к содержимому страницы, поскольку браузеры могут отображать статическое содержимое гораздо быстрее, чем содержимое, созданное на JavaScript. В то же время Nuxt сохраняет интерактивность веб-приложения во время процесса гидратации.
- **Оптимизация поисковых систем**: Универсальный рендеринг доставляет все HTML-содержимое страницы в браузер как классическое серверное приложение. Веб-краулеры могут напрямую индексировать содержимое страницы, что делает универсальный рендеринг отличным выбором для любого контента, который вы хотите быстро проиндексировать.

**Недостатки рендеринга на сервере:**
- **Ограничения разработки:** Среды сервера и браузера не предоставляют одни и те же API, и может быть сложно написать код, который мог бы беспрепятственно выполняться на обеих сторонах. К счастью, Nuxt предоставляет рекомендации и специальные переменные, которые помогут вам определить, где выполняется фрагмент кода.
- **Стоимость:** Чтобы отображать страницы «на лету», должен быть запущен сервер. Это добавляет ежемесячные расходы, как и у любого традиционного сервера. Однако количество вызовов сервера значительно сокращается благодаря универсальному рендерингу, когда браузер берет на себя навигацию на стороне клиента. Снижение затрат возможно за счет использования [пограничного рендеринга](#edge-side-rendering).

Универсальный рендеринг очень гибок и может подойти практически для любого варианта использования и особенно подходит для любых контентно-ориентированных веб-сайтов: **блоги, маркетинговые веб-сайты, портфолио, сайты электронной коммерции и торговые площадки.**

::tip
Дополнительные примеры написания кода Vue без несоответствия гидратации смотрите в [документации Vue](https://ru.vuejs.org/guide/scaling-up/ssr.html#hydration-mismatch).
::

::important
При импорте библиотеки, которая использует API браузера и имеет побочные эффекты, убедитесь, что импортирующий ее компонент вызывается только на стороне клиента. Бандлеры не обрабатывают импорт модулей, содержащих побочные эффекты.
::

## Рендеринг на клиенте

Из коробки традиционное Vue.js приложение рендерится в браузере (или **на клиенте**). После того, как браузер загрузит и спарсит весь JavaScript код, содержащий инструкции для создания текущего интерфейса, Vue.js генерирует HTML-элементы.

![Пользователям приходится ждать, пока браузер загрузит, спарсит и выполнит JavaScript, прежде чем увидеть содержимое страницы.](/assets/docs/concepts/rendering/csr.svg)

**Преимущества рендеринга на клиенте:**
- **Скорость разработки**: При работе полностью на клиенте нам не нужно беспокоиться о совместимости кода с сервером, например, при использовании API, доступного только для браузера, такого как объект `window`.
- **Дешевле:** Запуск сервера увеличивает стоимость инфраструктуры, поскольку вам потребуется работать на платформе, поддерживающей JavaScript. Мы можем размещать клиентские приложения на любом статическом сервере с файлами HTML, CSS и JavaScript.
- **Оффлайн:** Поскольку код полностью выполняется в браузере, он может продолжать работать, даже если интернет недоступен.

**Недостатки рендеринга на клиенте:**
- **Производительность**: Пользователю приходится ждать, пока браузер загрузит, проанализирует и запустит файлы JavaScript. В зависимости от сети, в которой выполняется загрузка, и устройства пользователя, на котором выполняется анализ и выполнение, это может занять некоторое время и повлиять на пользовательский опыт.
- **Поисковая оптимизация**: Индексирование и обновление контента, доставленного посредством рендеринга на клиенте, занимает больше времени, чем при обработке HTML-документа, отрисованного на сервере. Это связано с недостатком производительности, который мы обсуждали, поскольку поисковые роботы не будут ждать полной визуализации интерфейса при первой попытке индексировать страницу. Вашему контенту потребуется больше времени, чтобы отобразиться и обновиться на страницах результатов поиска с рендерингом полностью на клиенте.

Рендеринг на клиенте - хороший выбор для очень интерактивных **веб приложений**, которые не нуждаются в индексации или которые пользователи посещают часто. Он может использовать кэширование браузера, чтобы пропускать этап загрузки при последующих посещениях, например, **SaaS, приложений бэк-офиса или онлайн-игр**.

Вы можете включить рендеринг только на клиенте с помощью Nuxt в вашем `nuxt.config.ts`:

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  ssr: false
})
```

::note
Если вы успользуете `ssr: false`, вы должны поместить в `~/app/spa-loading-template.html` HTML-файл с некоторым HTML-кодом, который вы хотите использовать для рендеринга экрана загрузки, который будет отображаться до тех пор, пока ваше приложение не будет гидратировано.
:read-more{title="SPA Loading Template" to="/docs/api/configuration/nuxt-config#spaloadingtemplate"}
::

::tip{to="https://www.youtube.com/watch?v=7Lr0QTP1Ro8" icon="i-logos-youtube-icon" target="_blank"}
Посмотрите видео Александра Лихтера про **Создание чистого SPA с Nuxt!?**.
::

### Развертывание статичного приложения, отрисованного на стороне клиента

Если вы размещаете приложение на [статичном хостинге](/docs/getting-started/deployment#static-hosting) с помощью команд `nuxi generate` или `nuxi build --prerender`, то по умолчанию Nuxt будет рендерить каждую страницу как отдельный статичный HTML-файл.

Если вы используете рендеринг полностью на клиенте, тогда это может быть ненужно. Возможно, вам понадобится только один `index.html` файл, плюс запасные `200.html` и `404.html`, которые вы можете указать своему статическому веб-хосту для обслуживания всех запросов.
::warning
Если вы пререндерите свое приложение с помощью команд `nuxi generate` или `nuxi build --prerender`, то вы не сможете использовать серверные эндпоинты, поскольку сервер не будет включен в папку вывода. Если вам нужна серверная функциональность, используйте команду `nuxi build`.
::

Чтобы добиться этого, мы можем поменять способ рендеринга маршрутов. Просто добавьте это к [вашим хукам](/docs/api/advanced/hooks#nuxt-hooks-build-time) в `nuxt.config.ts`:

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  hooks: {
    'prerender:routes' ({ routes }) {
      routes.clear() // Не создает никаких маршрутов (кроме значений по умолчанию)
    }
  },
})
```

Это создаст три файла:

- `index.html`
- `200.html`
- `404.html`

`200.html` и `404.html` могут быть полезны для используемого вами хостинг-провайдера.

#### Пропуск генерации резервных файлов клиента

При пререндеринге клиентского приложения Nuxt по умолчанию генерирует файлы `index.html`, `200.html` и `404.html`. Однако, если вам нужно предотвратить генерацию любого (или всех) из этих файлов в вашей сборке, вы можете использовать хук `'prerender:generate'` из [Nitro](/docs/getting-started/prerendering#prerendergenerate-nitro-hook).

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  ssr: false,
  nitro: {
    hooks: {
      'prerender:generate'(route) {
        const routesToSkip = ['/index.html', '/200.html', '/404.html']
        if (routesToSkip.includes(route.route)) {
          route.skip = true
        }
      }
    }
  }
})
```

## Гибридный рендеринг

Гибридный рендеринг допускает разные правила кэширования для каждого маршрута, используя **правила маршрутизации**, и решает, как сервер должен отвечать на новый запрос по заданному URL.

Раньше каждый маршрут/страница Nuxt-приложения и сервер должны были использовать одинаковый режим рендеринга, универсальный или клиентский. В различных случаях некоторые страницы должны быть созданы во время сборки, в то время как другие должны быть отрисованы на клиенте. Например, подумайте о контентных сайтах с админ-частью. Каждая страница с контеном должна быть в первую очередь статической и генерироваться один раз, но админ-часть требует регистрации и ведет себя скорее как динамическое приложение.

Nuxt включает в себя правила маршрутизации и поддержку гибридного рендеринга. Используя правила маршрутизации, вы можете определить правила для группы маршрутов nuxt, меняя режим рендеринга или назначая стратегию кэширования, основанную на маршруте!

Nuxt-сервер будет автоматически регистрировать соответствующие middleware и оборачивать маршруты обработчиками кэша, используя [слой кеширования Nitro](https://nitro.unjs.io/guide/cache).

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  routeRules: {
    // Домашняя страница предварительно отрисовывается во время сборки
    '/': { prerender: true },
    // Страница продуктов создается по требованию, повторно проверяется в фоновом режиме, кэшируется до изменения ответа API
    '/products': { swr: true },
    // Страницы продукта создается по требованию, повторно проверяется в фоновом режиме, кэшируется на один час (3600 секунд)
    '/products/**': { swr: 3600 },
    // Страница сообщений в блоге создается по требованию, повторно проверяется в фоновом режиме, кэшируется на CDN на один час (3600 секунд)
    '/blog': { isr: 3600 },
    // Страница сообщения в блоге создается по требованию до следующего развертывания, кэшируется на CDN
    '/blog/**': { isr: true },
    // Панель управления администратора рендерится только на клиенте
    '/admin/**': { ssr: false },
    // Добавляет CORS-заголовки на маршрутах API
    '/api/**': { cors: true },
    // Перенаправляет старые URL-адреса
    '/old-page': { redirect: '/new-page' }
  }
})
```

### Правила маршрутизации

Вы можете использовать следующие свойства:
- `redirect: string`{lang=ts} - Определяет перенаправления на сервере.
- `ssr: boolean`{lang=ts} - Отключaет серверный рендеринг HTML для разделов вашего приложения, чтобы они рендерились только в браузере.`ssr: false`.
- `cors: boolean`{lang=ts} - Автоматически добавляет cors-заголовки с `cors: true` - вы можете настроить вывод, переопределив с помощью `headers`.
- `headers: object`{lang=ts} - Добавляет определенные заголовки в разделы вашего сайта, например, в ассеты.
- `swr: number | boolean`{lang=ts} - Добавляет заголовки кэша к ответу сервера и кэширует его на сервере или обратном прокси-сервере для настраиваемого TTL (time to live - времени жизни). Настройка Nitro `node-server` способна кэшировать полный ответ. По истечении срока жизни (TTL) будет отправлен кэшированный ответ, а страница будет перегенерирована в фоновом режиме. Если импользуется `true`, будет добавлен заголовок `stale-while-revalidate` без MaxAge.
- `isr: number | boolean`{lang=ts} - Поведение схоже с `swr`, за исключением того, что мы можем добавить ответ в кеш CDN на платформах, которые это поддерживают (в настоящее время Netlify или Vercel). Если используется `true`, контент сохраняется до следующего развертывания внутри CDN.
- `prerender: boolean`{lang=ts} - Предварительно отрисовывает маршруты во время сборки и включает их в сборку как статические ресурсы.
- `experimentalNoScripts: boolean`{lang=ts} - Отключает рендеринг скриптов Nuxt и подсказок ресурсов JS для разделов вашего сайта.
- `appMiddleware: string | string[] | Record<string, boolean>`{lang=ts} - Позволяет вам определить middleware, которое должно или не должно запускаться для путей к страницам в части Vue вашего приложения (то есть не для ваших маршрутов Nitro).

По возможности правила маршрутизации будут автоматически применяться к собственным правилам платформы развертывания для достижения оптимальной производительности (в настоящее время поддерживаются Netlify и Vercel).

::important
Обратите внимание, что гибридный рендеринг недоступен при использовании [`nuxt generate`](/docs/api/commands/generate).
::

**Примеры:**

::card-group
  ::card
  ---
  icon: i-simple-icons-github
  title: Nuxt Vercel ISR
  to: https://github.com/danielroe/nuxt-vercel-isr
  target: _blank
  ui.icon.base: text-black dark:text-white
  ---
  Пример Nuxt-приложения с гибридным рендерингом, развернутом на Vercel.
  ::
::

## Пограничный рендеринг

Пограничный рендеринг (Edge-Side Rendering - ESR) — это мощная функция, представленная в Nuxt, которая позволяет отображать ваше приложение Nuxt ближе к вашим пользователям через пограничные серверы сети доставки контента (CDN). Используя ESR, вы можете обеспечить повышенную производительность и сокращение задержек, тем самым обеспечивая улучшенный пользовательский опыт.

При использовании ESR процесс рендеринга переносится на «край» сети — пограничные серверы CDN. Обратите внимание, что ESR — это скорее цель развертывания, чем реальный режим рендеринга.

Когда делается запрос страницы, вместо того, чтобы дойти до исходного сервера, он перехватывается ближайшим пограничным сервером. Этот сервер генерирует HTML для страницы и отправляет его обратно пользователю. Этот процесс минимизирует физическое расстояние, которое должны пройти данные, **уменьшая задержку и ускоряя загрузку страницы**.

Пограничный рендеринг возможен, благодаря [Nitro](https://nitro.unjs.io) - [серверному движку](/docs/guide/concepts/server-engine) - который обеспечивает работу Nuxt 3. Он предлагает кроссплатформенную поддержку Node.js, Deno, Cloudflare Workers и других.

Текущие платформы, на которых вы можете использовать ESR:
- [Cloudflare Pages](https://pages.cloudflare.com) с нулевой конфигурацией с использованием git-интеграции и команды `nuxt build`
- [Vercel Edge Functions](https://vercel.com/features/edge-functions) с использованием команды `nuxt build` и переменной окружения `NITRO_PRESET=vercel-edge`
- [Netlify Edge Functions](https://www.netlify.com/products/#netlify-edge-functions) с использованием команды `nuxt build` и переменной окружения `NITRO_PRESET=netlify-edge`

Обратите внимание, что **гибридный рендеринг** можно использовать при использовании пограничного рендеринга с правилами маршрутизации.

Вы можете изучить примеры с открытым исходным кодом, развернутые на некоторых платформах, упомянутых выше:
::card-group
  ::card
  ---
  icon: i-simple-icons-github
  title: Nuxt Todos Edge
  to: https://github.com/atinux/nuxt-todos-edge
  target: _blank
  ui.icon.base: text-black dark:text-white
  ---
  Приложение со списком дел с аутентификацией пользователей, SSR и SQLite.
  ::
  ::card
  ---
  icon: i-simple-icons-github
  title: Atinotes
  to: https://github.com/atinux/atinotes
  target: _blank
  ui.icon.base: text-black dark:text-white
  ---
  Редактируемый сайт с универсальным рендерингом на Cloudflare KV.
  ::
::

<!-- TODO: link to templates with ESR category for examples -->
