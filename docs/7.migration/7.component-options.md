---
title: "Опции компонентов"
description: "Миграция с опций компонентов Nuxt 2 на компосаблы Nuxt 3."
---

## `asyncData` и `fetch`

В Nuxt 3 данные с API получают [новыми способами](/docs/4.x/getting-started/data-fetching).

<!-- TODO: Intro to <script setup> -->
<!-- TODO: Mention about options compatibility with asyncData -->

### Изоморфный fetch

В Nuxt 2 часто использовали `@nuxtjs/axios`, `@nuxt/http` или глобальный полифилл `fetch`.

В Nuxt 3 доступны глобальный `fetch` с API [Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch) или [`$fetch`](/docs/4.x/api/utils/dollarfetch) на базе [unjs/ofetch](https://github.com/unjs/ofetch). Преимущества:

1. На сервере выполняет [прямые вызовы API](/docs/4.x/guide/concepts/server-engine#direct-api-calls), на клиенте — запрос к вашему API (поддерживаются и сторонние API).
2. Удобная обработка: авто-парсинг ответов и сериализация данных.

Подробнее: [прямые вызовы API](/docs/4.x/guide/concepts/server-engine#direct-api-calls), [получение данных](/docs/4.x/getting-started/data-fetching).

### Композаблы

В Nuxt 3 для получения данных используются [`useAsyncData`](/docs/4.x/api/composables/use-async-data) и `useFetch`. Есть «ленивые» варианты (`useLazyAsyncData`, `useLazyFetch`) — они не блокируют навигацию на клиенте.

В Nuxt 2 данные запрашивали в компоненте так:

```ts
export default {
  async asyncData ({ params, $http }) {
    const post = await $http.$get(`https://api.nuxtjs.dev/posts/${params.id}`)
    return { post }
  },
  // or alternatively
  fetch () {
    this.post = await $http.$get(`https://api.nuxtjs.dev/posts/${params.id}`)
  },
}
```

В методах и шаблоне переменная `post` использовалась как обычные данные компонента.

В Nuxt 3 тот же запрос делается композаблами в `setup()` или в `<script setup>`:

```vue
<script setup lang="ts">
// params — из defineProps(), useRoute() и т.д.
const { data: post, refresh } = await useAsyncData('post', () => $fetch(`https://api.nuxtjs.dev/posts/${params.id}`))
// Или useFetch — обёртка над useAsyncData для простого запроса
const { data: post, refresh } = await useFetch(`https://api.nuxtjs.dev/posts/${params.id}`)
</script>
```

В шаблоне Nuxt 3 доступны `post` и вызов `refresh()` для обновления данных.

::note
[`useFetch`](/docs/4.x/api/composables/use-fetch) — не прямая замена хука `fetch()`. Оба хука заменяет [`useAsyncData`](/docs/4.x/api/composables/use-async-data); она гибче и подходит не только для запросов к одному endpoint. [`useFetch`](/docs/4.x/api/composables/use-fetch) — удобная обёртка над [`useAsyncData`](/docs/4.x/api/composables/use-async-data) для простого запроса.
::

### Миграция

1. Замените хук `asyncData` на [`useAsyncData`](/docs/4.x/api/composables/use-async-data) или [`useFetch`](/docs/4.x/api/composables/use-fetch) в странице/компоненте.
2. Замените хук `fetch` на [`useAsyncData`](/docs/4.x/api/composables/use-async-data) или [`useFetch`](/docs/4.x/api/composables/use-fetch).

## `head`

:read-more{to="/docs/4.x/migration/meta"}

## `key`

Ключ задаётся в макросе [`definePageMeta`](/docs/4.x/api/utils/define-page-meta).

```diff [app/pages/index.vue]
- <script>
- export default {
-   key: 'index'
-   // or a method
-   // key: route => route.fullPath
- }
+ <script setup>
+ definePageMeta({
+   key: 'index'
+   // or a method
+   // key: route => route.fullPath
+ })
</script>
```

## `layout`

:read-more{to="/docs/4.x/migration/pages-and-layouts"}

## `loading`

В Nuxt 3 пока не поддерживается.

## `middleware`

:read-more{to="/docs/4.x/migration/plugins-and-middleware"}

## `scrollToTop`

В Nuxt 3 пока не поддерживается. Поведение скролла `vue-router` можно переопределить в `~/router.options.ts` (см. [документацию](/docs/4.x/guide/recipes/custom-routing#router-options)).
Как и `key`, задаётся в макросе [`definePageMeta`](/docs/4.x/api/utils/define-page-meta).

```diff [app/pages/index.vue]
- <script>
- export default {
-   scrollToTop: false
- }
+ <script setup>
+ definePageMeta({
+   scrollToTop: false
+ })
</script>
```

## `transition`

:read-more{to="/docs/4.x/getting-started/transitions"}

## `validate`

Хук validate в Nuxt 3 принимает один аргумент — `route`. Как и в Nuxt 2, можно вернуть boolean; при `false` и отсутствии другого совпадения будет 404. Можно вернуть объект с `status`/`statusText` для немедленного ответа с ошибкой (остальные маршруты не проверяются).

```diff [app/pages/users/[id\\].vue]
- <script>
- export default {
-   async validate({ params }) {
-     return /^\d+$/.test(params.id)
-   }
- }
+ <script setup>
+ definePageMeta({
+   validate: async (route) => {
+     const nuxtApp = useNuxtApp()
+     return /^\d+$/.test(route.params.id)
+   }
+ })
  </script>
```

## `watchQuery`

В Nuxt 3 не поддерживается. Используйте watcher для повторной загрузки данных.

```vue [app/pages/users/[id\\].vue]
<script setup lang="ts">
const route = useRoute()
const { data, refresh } = await useFetch('/api/user')
watch(() => route.query, () => refresh())
</script>
```
